diff --git a/src/main/java/com/google/devtools/build/lib/analysis/BuildView.java b/src/main/java/com/google/devtools/build/lib/analysis/BuildView.java
index ea261a9ad2..5c8421e9e7 100644
--- a/src/main/java/com/google/devtools/build/lib/analysis/BuildView.java
+++ b/src/main/java/com/google/devtools/build/lib/analysis/BuildView.java
@@ -410,7 +410,7 @@ public class BuildView {
               "Analysis succeeded for only %d of %d top-level targets",
               numSuccessful, numTargetsToAnalyze);
       eventHandler.handle(Event.info(msg));
-      logger.atInfo().log(msg);
+      logger.atInfo().log("%s", msg);
     }
 
     AnalysisResult result;
diff --git a/src/main/java/com/google/devtools/build/lib/authandtls/AuthAndTLSOptions.java b/src/main/java/com/google/devtools/build/lib/authandtls/AuthAndTLSOptions.java
index 2a54e3d7f9..c88e24d825 100644
--- a/src/main/java/com/google/devtools/build/lib/authandtls/AuthAndTLSOptions.java
+++ b/src/main/java/com/google/devtools/build/lib/authandtls/AuthAndTLSOptions.java
@@ -131,4 +131,14 @@ public class AuthAndTLSOptions extends OptionsBase {
               + "granularity; it is an error to set a value less than one second. If keep-alive "
               + "pings are disabled, then this setting is ignored.")
   public Duration grpcKeepaliveTimeout;
+
+  @Option(
+    name = "aws_profile",
+    defaultValue = "null",
+    documentationCategory = OptionDocumentationCategory.UNCATEGORIZED,
+    effectTags = {OptionEffectTag.UNKNOWN},
+    help = "Name of profile in ~/.aws/credentials to use for S3 caching"
+  )
+  public String awsProfile;
+
 }
diff --git a/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceModule.java b/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceModule.java
index 463551c9de..b352779c72 100644
--- a/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceModule.java
+++ b/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceModule.java
@@ -163,7 +163,7 @@ public abstract class BuildEventServiceModule<BESOptionsT extends BuildEventServ
     // Don't hide unchecked exceptions as part of the error reporting.
     Throwables.throwIfUnchecked(exception);
 
-    logger.atSevere().withCause(exception).log(msg);
+    logger.atSevere().withCause(exception).log("%s", msg);
     reportCommandLineError(commandLineReporter, exception);
     moduleEnvironment.exit(createAbruptExitException(exception, msg, besCode));
   }
@@ -254,7 +254,7 @@ public abstract class BuildEventServiceModule<BESOptionsT extends BuildEventServ
                   + "Cancelling and starting a new invocation...",
               waitedMillis / 1000, waitedMillis % 1000);
       reporter.handle(Event.warn(msg));
-      logger.atWarning().withCause(exception).log(msg);
+      logger.atWarning().withCause(exception).log("%s", msg);
       cancelCloseFutures = true;
     } catch (ExecutionException e) {
       String msg;
@@ -274,7 +274,7 @@ public abstract class BuildEventServiceModule<BESOptionsT extends BuildEventServ
                 e.getMessage());
       }
       reporter.handle(Event.warn(msg));
-      logger.atWarning().withCause(e).log(msg);
+      logger.atWarning().withCause(e).log("%s", msg);
       cancelCloseFutures = true;
     } finally {
       if (cancelCloseFutures) {
@@ -671,7 +671,7 @@ public abstract class BuildEventServiceModule<BESOptionsT extends BuildEventServ
           String.format(
               "Build Event Service uploads disabled due to a connectivity problem: %s", status);
       reporter.handle(Event.warn(message));
-      logger.atWarning().log(message);
+      logger.atWarning().log("%s", message);
       return null;
     }
 
diff --git a/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceUploader.java b/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceUploader.java
index 748a6743f0..16b9e9e98a 100644
--- a/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceUploader.java
+++ b/src/main/java/com/google/devtools/build/lib/buildeventservice/BuildEventServiceUploader.java
@@ -293,7 +293,7 @@ public final class BuildEventServiceUploader implements Runnable {
 
   private DetailedExitCode logAndSetException(
       String message, BuildProgress.Code bpCode, Throwable cause) {
-    logger.atSevere().log(message);
+    logger.atSevere().log("%s", message);
     DetailedExitCode detailedExitCode =
         DetailedExitCode.of(
             FailureDetail.newBuilder()
@@ -490,7 +490,7 @@ public final class BuildEventServiceUploader implements Runnable {
                       String.format(
                           "Expected ACK with seqNum=%d but received ACK with seqNum=%d",
                           expected.getSequenceNumber(), actualSeqNum);
-                  logger.atInfo().log(message);
+                  logger.atInfo().log("%s", message);
                   streamContext.abortStream(Status.FAILED_PRECONDITION.withDescription(message));
                 }
               } else {
@@ -498,7 +498,7 @@ public final class BuildEventServiceUploader implements Runnable {
                     String.format(
                         "Received ACK (seqNum=%d) when no ACK was expected",
                         ackEvent.getSequenceNumber());
-                logger.atInfo().log(message);
+                logger.atInfo().log("%s", message);
                 streamContext.abortStream(Status.FAILED_PRECONDITION.withDescription(message));
               }
             }
@@ -537,7 +537,7 @@ public final class BuildEventServiceUploader implements Runnable {
               if (!shouldRetryStatus(streamStatus)) {
                 String message =
                     String.format("Not retrying publishBuildEvents: status='%s'", streamStatus);
-                logger.atInfo().log(message);
+                logger.atInfo().log("%s", message);
                 throw withFailureDetail(
                     streamStatus.asException(),
                     BuildProgress.Code.BES_STREAM_NOT_RETRYING_FAILURE,
@@ -548,7 +548,7 @@ public final class BuildEventServiceUploader implements Runnable {
                     String.format(
                         "Not retrying publishBuildEvents, no more attempts left: status='%s'",
                         streamStatus);
-                logger.atInfo().log(message);
+                logger.atInfo().log("%s", message);
                 throw withFailureDetail(
                     streamStatus.asException(),
                     BuildProgress.Code.BES_UPLOAD_RETRY_LIMIT_EXCEEDED_FAILURE,
@@ -636,7 +636,7 @@ public final class BuildEventServiceUploader implements Runnable {
         if (!shouldRetryStatus(e.getStatus())) {
           String message =
               String.format("Not retrying publishLifecycleEvent: status='%s'", e.getStatus());
-          logger.atInfo().log(message);
+          logger.atInfo().log("%s", message);
           throw withFailureDetail(e, BuildProgress.Code.BES_STREAM_NOT_RETRYING_FAILURE, message);
         }
 
diff --git a/src/main/java/com/google/devtools/build/lib/buildeventstream/transports/FileTransport.java b/src/main/java/com/google/devtools/build/lib/buildeventstream/transports/FileTransport.java
index 01ab3d1011..500dba1609 100644
--- a/src/main/java/com/google/devtools/build/lib/buildeventstream/transports/FileTransport.java
+++ b/src/main/java/com/google/devtools/build/lib/buildeventstream/transports/FileTransport.java
@@ -186,7 +186,7 @@ abstract class FileTransport implements BuildEventTransport {
                       .build()),
               e));
       pendingWrites.clear();
-      logger.atSevere().withCause(e).log(message);
+      logger.atSevere().withCause(e).log("%s", message);
     }
 
     private static BuildProgress.Code getBuildProgressCode(Throwable e) {
@@ -329,4 +329,3 @@ abstract class FileTransport implements BuildEventTransport {
     return writer.getFlushInterval();
   }
 }
-
diff --git a/src/main/java/com/google/devtools/build/lib/buildtool/ExecutionTool.java b/src/main/java/com/google/devtools/build/lib/buildtool/ExecutionTool.java
index 245e08ab1b..b1213ab776 100644
--- a/src/main/java/com/google/devtools/build/lib/buildtool/ExecutionTool.java
+++ b/src/main/java/com/google/devtools/build/lib/buildtool/ExecutionTool.java
@@ -578,7 +578,7 @@ public class ExecutionTool {
         for (Path entry : entries) {
           directoryDetails.append(" '").append(entry.getBaseName()).append("'");
         }
-        logger.atWarning().log(directoryDetails.toString());
+        logger.atWarning().log("%s", directoryDetails.toString());
       } catch (IOException e) {
         logger.atWarning().withCause(e).log("'%s' exists but could not be read", directory);
       }
diff --git a/src/main/java/com/google/devtools/build/lib/exec/local/LocalSpawnRunner.java b/src/main/java/com/google/devtools/build/lib/exec/local/LocalSpawnRunner.java
index 46894f941d..351bfc8307 100644
--- a/src/main/java/com/google/devtools/build/lib/exec/local/LocalSpawnRunner.java
+++ b/src/main/java/com/google/devtools/build/lib/exec/local/LocalSpawnRunner.java
@@ -251,7 +251,7 @@ public class LocalSpawnRunner implements SpawnRunner {
         Level level, @Nullable Throwable cause, @FormatString String fmt, Object... args) {
       String msg = String.format(fmt, args);
       String toLog = String.format("%s (#%d %s)", msg, id, desc());
-      logger.at(level).withCause(cause).log(toLog);
+      logger.at(level).withCause(cause).log("%s", toLog);
     }
 
     private String desc() {
diff --git a/src/main/java/com/google/devtools/build/lib/platform/SystemSuspensionModule.java b/src/main/java/com/google/devtools/build/lib/platform/SystemSuspensionModule.java
index 9a9b9db54d..ff80e0985a 100644
--- a/src/main/java/com/google/devtools/build/lib/platform/SystemSuspensionModule.java
+++ b/src/main/java/com/google/devtools/build/lib/platform/SystemSuspensionModule.java
@@ -59,7 +59,7 @@ public final class SystemSuspensionModule extends BlazeModule {
       String logString = event.logString();
       reporter.handle(Event.info(logString));
       reporter.post(event);
-      logger.atInfo().log(logString);
+      logger.atInfo().log("%s", logString);
     }
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java
index 57741a8f28..d0c3a680dd 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteCacheClientFactory.java
@@ -14,6 +14,7 @@
 
 package com.google.devtools.build.lib.remote;
 
+import com.google.devtools.build.lib.authandtls.AuthAndTLSOptions;
 import com.google.auth.Credentials;
 import com.google.common.base.Ascii;
 import com.google.common.base.Preconditions;
@@ -31,6 +32,55 @@ import java.io.IOException;
 import java.net.URI;
 import javax.annotation.Nullable;
 
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+class IniFile {
+
+    private Pattern  _section  = Pattern.compile( "\\s*\\[([^]]*)\\]\\s*" );
+    private Pattern  _keyValue = Pattern.compile( "\\s*([^=]*)=(.*)" );
+    private Map< String,
+            Map< String,
+            String >>  _entries  = new HashMap<>();
+
+    public IniFile( String path ) throws IOException {
+        try( BufferedReader br = new BufferedReader( new FileReader( path ))) {
+            String line;
+            String section = null;
+            while(( line = br.readLine()) != null ) {
+                Matcher m = _section.matcher( line );
+                if( m.matches()) {
+                    section = m.group( 1 ).trim();
+                }
+                else if( section != null ) {
+                    m = _keyValue.matcher( line );
+                    if( m.matches()) {
+                        String key   = m.group( 1 ).trim();
+                        String value = m.group( 2 ).trim();
+                        Map< String, String > kv = _entries.get( section );
+                        if( kv == null ) {
+                            _entries.put( section, kv = new HashMap<>());
+                        }
+                        kv.put( key, value );
+                    }
+                }
+            }
+        }
+    }
+
+    public String getString(String section, String key) throws IOException {
+        Map< String, String > kv = _entries.get( section );
+        if( kv == null ) {
+            throw new IOException("Failed to read INI key: " + key);
+        }
+        return kv.get( key );
+    }
+}
 /**
  * A factory class for providing a {@link RemoteCacheClient}. Currently implemented for HTTP and
  * disk caching.
@@ -56,15 +106,16 @@ public final class RemoteCacheClientFactory {
       RemoteOptions options,
       @Nullable Credentials creds,
       Path workingDirectory,
-      DigestUtil digestUtil)
+      DigestUtil digestUtil,
+      AuthAndTLSOptions authAndTLSOptions)
       throws IOException {
     Preconditions.checkNotNull(workingDirectory, "workingDirectory");
     if (isHttpCache(options) && isDiskCache(options)) {
       return createDiskAndHttpCache(
-          workingDirectory, options.diskCache, options, creds, digestUtil);
+          workingDirectory, options.diskCache, options, creds, digestUtil, authAndTLSOptions);
     }
     if (isHttpCache(options)) {
-      return createHttp(options, creds, digestUtil);
+      return createHttp(options, creds, digestUtil, authAndTLSOptions);
     }
     if (isDiskCache(options)) {
       return createDiskCache(
@@ -80,7 +131,8 @@ public final class RemoteCacheClientFactory {
   }
 
   private static RemoteCacheClient createHttp(
-      RemoteOptions options, Credentials creds, DigestUtil digestUtil) {
+      RemoteOptions options, Credentials creds, DigestUtil digestUtil,
+      AuthAndTLSOptions authAndTLSOptions) {
     Preconditions.checkNotNull(options.remoteCache, "remoteCache");
 
     try {
@@ -99,11 +151,24 @@ public final class RemoteCacheClientFactory {
               options.remoteVerifyDownloads,
               ImmutableList.copyOf(options.remoteHeaders),
               digestUtil,
-              creds);
+              creds,
+              null, null);
         } else {
           throw new Exception("Remote cache proxy unsupported: " + options.remoteProxy);
         }
       } else {
+        String awsId = null;
+        String awsSecret = null;
+        if(authAndTLSOptions.awsProfile != null) {
+            String home = System.getenv("HOME");
+            try {
+                IniFile iniFile = new IniFile(home +"/.aws/credentials");
+                awsId = iniFile.getString(authAndTLSOptions.awsProfile, "aws_access_key_id");
+                awsSecret = iniFile.getString(authAndTLSOptions.awsProfile, "aws_secret_access_key");
+            } catch(Exception e) {
+                throw new Exception("Failed to read aws profile: " + authAndTLSOptions.awsProfile + " from ~/.aws/credentials");
+            }
+        }
         return HttpCacheClient.create(
             uri,
             Math.toIntExact(options.remoteTimeout.getSeconds()),
@@ -111,7 +176,8 @@ public final class RemoteCacheClientFactory {
             options.remoteVerifyDownloads,
             ImmutableList.copyOf(options.remoteHeaders),
             digestUtil,
-            creds);
+            creds,
+            awsId, awsSecret);
       }
     } catch (Exception e) {
       throw new RuntimeException(e);
@@ -137,7 +203,8 @@ public final class RemoteCacheClientFactory {
       PathFragment diskCachePath,
       RemoteOptions options,
       Credentials cred,
-      DigestUtil digestUtil)
+      DigestUtil digestUtil,
+      AuthAndTLSOptions authAndTLSOptions)
       throws IOException {
     Path cacheDir =
         workingDirectory.getRelative(Preconditions.checkNotNull(diskCachePath, "diskCachePath"));
@@ -145,7 +212,7 @@ public final class RemoteCacheClientFactory {
       cacheDir.createDirectoryAndParents();
     }
 
-    RemoteCacheClient httpCache = createHttp(options, cred, digestUtil);
+    RemoteCacheClient httpCache = createHttp(options, cred, digestUtil, authAndTLSOptions);
     return createDiskAndRemoteClient(
         workingDirectory,
         diskCachePath,
diff --git a/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java b/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
index 0e165d1521..608feba349 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/RemoteModule.java
@@ -115,6 +115,7 @@ import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import javax.annotation.Nullable;
 
+
 /** RemoteModule provides distributed cache and remote execution for Bazel. */
 public final class RemoteModule extends BlazeModule {
 
@@ -212,6 +213,7 @@ public final class RemoteModule extends BlazeModule {
       AuthAndTLSOptions authAndTlsOptions,
       RemoteOptions remoteOptions,
       DigestUtil digestUtil) {
+
     Credentials creds;
     try {
       creds =
@@ -232,7 +234,8 @@ public final class RemoteModule extends BlazeModule {
               remoteOptions,
               creds,
               Preconditions.checkNotNull(env.getWorkingDirectory(), "workingDirectory"),
-              digestUtil);
+              digestUtil,
+              authAndTlsOptions);
     } catch (IOException e) {
       handleInitFailure(env, e, Code.CACHE_INIT_FAILURE);
       return;
@@ -387,6 +390,7 @@ public final class RemoteModule extends BlazeModule {
     if (cacheChannel == null) {
       ImmutableList.Builder<ClientInterceptor> interceptors = ImmutableList.builder();
       interceptors.add(TracingMetadataUtils.newCacheHeadersInterceptor(remoteOptions));
+
       if (loggingInterceptor != null) {
         interceptors.add(loggingInterceptor);
       }
@@ -868,7 +872,7 @@ public final class RemoteModule extends BlazeModule {
       failure = e;
       failureCode = Code.RPC_LOG_FAILURE;
       failureMessage = "Partially wrote rpc log file";
-      logger.atWarning().withCause(e).log(failureMessage);
+      logger.atWarning().withCause(e).log("%s", failureMessage);
     }
 
     executorService = null;
diff --git a/src/main/java/com/google/devtools/build/lib/remote/http/AbstractHttpHandler.java b/src/main/java/com/google/devtools/build/lib/remote/http/AbstractHttpHandler.java
index 54634edb21..100c3747df 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/http/AbstractHttpHandler.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/http/AbstractHttpHandler.java
@@ -17,37 +17,56 @@ import static java.nio.charset.StandardCharsets.UTF_8;
 
 import com.google.auth.Credentials;
 import com.google.common.collect.ImmutableList;
+import com.google.common.flogger.GoogleLogger;
 import com.google.common.io.BaseEncoding;
 import com.google.devtools.build.lib.analysis.BlazeVersionInfo;
+import com.google.devtools.build.lib.authandtls.AuthAndTLSOptions;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpRequest;
 import java.io.IOException;
 import java.net.SocketAddress;
 import java.net.URI;
 import java.nio.channels.ClosedChannelException;
+import java.text.SimpleDateFormat;
+import java.util.Base64;
+import java.util.Calendar;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.TimeZone;
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
 
 /** Common functionality shared by concrete classes. */
 abstract class AbstractHttpHandler<T extends HttpObject> extends SimpleChannelInboundHandler<T>
     implements ChannelOutboundHandler {
 
+  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();
+
   private static final String USER_AGENT_VALUE =
       "bazel/" + BlazeVersionInfo.instance().getVersion();
 
   private final Credentials credentials;
   private final ImmutableList<Entry<String, String>> extraHttpHeaders;
 
+  private String awsId;
+  private String awsSecret;
+
   public AbstractHttpHandler(
-      Credentials credentials, ImmutableList<Entry<String, String>> extraHttpHeaders) {
+      Credentials credentials,
+      ImmutableList<Entry<String, String>> extraHttpHeaders,
+      String awsId, String awsSecret) {
     this.credentials = credentials;
     this.extraHttpHeaders = extraHttpHeaders;
+    this.awsId = awsId;
+    this.awsSecret = awsSecret;
   }
 
   protected ChannelPromise userPromise;
@@ -60,6 +79,75 @@ abstract class AbstractHttpHandler<T extends HttpObject> extends SimpleChannelIn
     userPromise = null;
   }
 
+  private static String getServerTime() {
+    Calendar calendar = Calendar.getInstance();
+    SimpleDateFormat dateFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return dateFormat.format(calendar.getTime());
+  }
+
+  private static String hmacSha1(String key, String data) {
+    try {
+      Mac mac = Mac.getInstance("HmacSHA1");
+      SecretKeySpec secret = new SecretKeySpec(key.getBytes(), "HmacSHA1");
+      mac.init(secret);
+      byte[] digest = mac.doFinal(data.getBytes());
+      String out = Base64.getEncoder().encodeToString(digest);
+      return out;
+    } catch (Exception e) {
+      logger.atWarning().withCause(e).log("failed to setup aws creds");
+      return "";
+    }
+  }
+
+  protected void addAwsAuthenticationHeaders(HttpRequest request, String path) throws IOException {
+    if (awsId == null || awsSecret == null) {
+      return;
+    }
+
+    // x-amz-date
+    String dateStr = getServerTime();
+    request.headers().add("x-amz-date", dateStr);
+
+    String toHash;
+    //   StringToSign = HTTP-Verb + "\n" +
+    //   Content-MD5 + "\n" +  (optional)
+    //   Content-Type + "\n" + (optional)
+    //   Date + "\n" +
+    //   CanonicalizedAmzHeaders +
+    //   CanonicalizedResource;
+    if (request.getMethod() == HttpMethod.GET) {
+      // GET\n
+      // \n
+      // \n
+      // Tue, 27 Mar 2007 19:36:42 +0000\n
+      // /photos/blob
+      toHash = "GET\n\n\n\nx-amz-date:" + dateStr + "\n" + path;
+    } else if (request.getMethod() == HttpMethod.PUT) {
+      // PUT\n
+      // \n
+      // application/octet-stream\n
+      // Tue, 27 Mar 2007 21:15:45 +0000\n
+      // /photos/blob
+      toHash = "PUT\n\n\n\nx-amz-date:" + dateStr + "\n" + path;
+    } else {
+      return;
+    }
+
+    String sigStr = hmacSha1(awsSecret, toHash);
+    if (sigStr == "") {
+      return;
+    }
+    // Signature = Base64(
+    //  HMAC-SHA1(
+    //     UTF-8-Encoding-Of(YourSecretAccessKey),
+    //     UTF-8-Encoding-Of( StringToSign )
+    //  )
+    // );
+    // Authorization = "AWS" + " " + AWSAccessKeyId + ":" + Signature;
+    request.headers().add("Authorization", "AWS " + awsId + ":" + sigStr);
+  }
+
   protected void addCredentialHeaders(HttpRequest request, URI uri) throws IOException {
     String userInfo = uri.getUserInfo();
     if (userInfo != null) {
diff --git a/src/main/java/com/google/devtools/build/lib/remote/http/BUILD b/src/main/java/com/google/devtools/build/lib/remote/http/BUILD
index 9ce71c7c52..67e7bd0a46 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/http/BUILD
+++ b/src/main/java/com/google/devtools/build/lib/remote/http/BUILD
@@ -19,6 +19,7 @@ java_library(
     ],
     deps = [
         "//src/main/java/com/google/devtools/build/lib/analysis:blaze_version_info",
+        "//src/main/java/com/google/devtools/build/lib/authandtls",
         "//src/main/java/com/google/devtools/build/lib/remote/common",
         "//src/main/java/com/google/devtools/build/lib/remote/util",
         "//src/main/java/com/google/devtools/build/lib/vfs",
diff --git a/src/main/java/com/google/devtools/build/lib/remote/http/HttpCacheClient.java b/src/main/java/com/google/devtools/build/lib/remote/http/HttpCacheClient.java
index 21b471e963..42f53e770c 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/http/HttpCacheClient.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/http/HttpCacheClient.java
@@ -88,6 +88,8 @@ import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 import javax.net.ssl.SSLEngine;
 
+import java.util.Optional;
+
 /**
  * Implementation of {@link RemoteCacheClient} that can talk to a HTTP/1.1 backend.
  *
@@ -130,6 +132,8 @@ public final class HttpCacheClient implements RemoteCacheClient {
   private final boolean useTls;
   private final boolean verifyDownloads;
   private final DigestUtil digestUtil;
+  private final String awsId;
+  private final String awsSecret;
 
   private final Object closeLock = new Object();
 
@@ -151,7 +155,8 @@ public final class HttpCacheClient implements RemoteCacheClient {
       boolean verifyDownloads,
       ImmutableList<Entry<String, String>> extraHttpHeaders,
       DigestUtil digestUtil,
-      @Nullable final Credentials creds)
+      @Nullable final Credentials creds,
+      String awsId, String awsSecret)
       throws Exception {
     return new HttpCacheClient(
         NioEventLoopGroup::new,
@@ -163,6 +168,7 @@ public final class HttpCacheClient implements RemoteCacheClient {
         extraHttpHeaders,
         digestUtil,
         creds,
+        awsId, awsSecret,
         null);
   }
 
@@ -174,7 +180,8 @@ public final class HttpCacheClient implements RemoteCacheClient {
       boolean verifyDownloads,
       ImmutableList<Entry<String, String>> extraHttpHeaders,
       DigestUtil digestUtil,
-      @Nullable final Credentials creds)
+      @Nullable final Credentials creds,
+      String awsId, String awsSecret)
       throws Exception {
 
     if (KQueue.isAvailable()) {
@@ -188,6 +195,7 @@ public final class HttpCacheClient implements RemoteCacheClient {
           extraHttpHeaders,
           digestUtil,
           creds,
+          awsId, awsSecret,
           domainSocketAddress);
     } else if (Epoll.isAvailable()) {
       return new HttpCacheClient(
@@ -200,6 +208,7 @@ public final class HttpCacheClient implements RemoteCacheClient {
           extraHttpHeaders,
           digestUtil,
           creds,
+          awsId, awsSecret,
           domainSocketAddress);
     } else {
       throw new Exception("Unix domain sockets are unsupported on this platform");
@@ -216,6 +225,7 @@ public final class HttpCacheClient implements RemoteCacheClient {
       ImmutableList<Entry<String, String>> extraHttpHeaders,
       DigestUtil digestUtil,
       @Nullable final Credentials creds,
+      String awsId, String awsSecret,
       @Nullable SocketAddress socketAddress)
       throws Exception {
     useTls = uri.getScheme().equals("https");
@@ -232,6 +242,9 @@ public final class HttpCacheClient implements RemoteCacheClient {
               uri.getFragment());
     }
     this.uri = uri;
+    this.awsId = awsId;
+    this.awsSecret = awsSecret;
+
     if (socketAddress == null) {
       socketAddress = new InetSocketAddress(uri.getHost(), uri.getPort());
     }
@@ -320,7 +333,7 @@ public final class HttpCacheClient implements RemoteCacheClient {
                 pipeline.addLast(new HttpRequestEncoder());
                 pipeline.addLast(new ChunkedWriteHandler());
                 synchronized (credentialsLock) {
-                  pipeline.addLast(new HttpUploadHandler(creds, extraHttpHeaders));
+                  pipeline.addLast(new HttpUploadHandler(creds, extraHttpHeaders, awsId, awsSecret));
                 }
 
                 if (!channel.eventLoop().inEventLoop()) {
@@ -387,7 +400,7 @@ public final class HttpCacheClient implements RemoteCacheClient {
                 pipeline.addLast(new HttpClientCodec());
                 pipeline.addLast("inflater", new HttpContentDecompressor());
                 synchronized (credentialsLock) {
-                  pipeline.addLast(new HttpDownloadHandler(creds, extraHttpHeaders));
+                  pipeline.addLast(new HttpDownloadHandler(creds, extraHttpHeaders, awsId, awsSecret));
                 }
 
                 if (!channel.eventLoop().inEventLoop()) {
@@ -482,6 +495,7 @@ public final class HttpCacheClient implements RemoteCacheClient {
             out.flush();
           }
         };
+
     DownloadCommand downloadCmd = new DownloadCommand(uri, casDownload, digest, wrappedOut);
     SettableFuture<Void> outerF = SettableFuture.create();
     acquireDownloadChannel()
diff --git a/src/main/java/com/google/devtools/build/lib/remote/http/HttpDownloadHandler.java b/src/main/java/com/google/devtools/build/lib/remote/http/HttpDownloadHandler.java
index 50d83d138a..9971e7d0cf 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/http/HttpDownloadHandler.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/http/HttpDownloadHandler.java
@@ -39,6 +39,8 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Map.Entry;
 
+import com.google.devtools.build.lib.authandtls.AuthAndTLSOptions;
+
 /** ChannelHandler for downloads. */
 final class HttpDownloadHandler extends AbstractHttpHandler<HttpObject> {
 
@@ -53,8 +55,8 @@ final class HttpDownloadHandler extends AbstractHttpHandler<HttpObject> {
   private String path;
 
   public HttpDownloadHandler(
-      Credentials credentials, ImmutableList<Entry<String, String>> extraHttpHeaders) {
-    super(credentials, extraHttpHeaders);
+      Credentials credentials, ImmutableList<Entry<String, String>> extraHttpHeaders, String awsId, String awsSecret) {
+    super(credentials, extraHttpHeaders, awsId, awsSecret);
   }
 
   @Override
@@ -137,10 +139,12 @@ final class HttpDownloadHandler extends AbstractHttpHandler<HttpObject> {
     DownloadCommand cmd = (DownloadCommand) msg;
     out = cmd.out();
     path = constructPath(cmd.uri(), cmd.digest().getHash(), cmd.casDownload());
+
     HttpRequest request = buildRequest(path, constructHost(cmd.uri()));
     addCredentialHeaders(request, cmd.uri());
     addExtraRemoteHeaders(request);
     addUserAgentHeader(request);
+    addAwsAuthenticationHeaders(request, path);
     ctx.writeAndFlush(request)
         .addListener(
             (f) -> {
diff --git a/src/main/java/com/google/devtools/build/lib/remote/http/HttpUploadHandler.java b/src/main/java/com/google/devtools/build/lib/remote/http/HttpUploadHandler.java
index 21e1a1f8b1..faf489bb30 100644
--- a/src/main/java/com/google/devtools/build/lib/remote/http/HttpUploadHandler.java
+++ b/src/main/java/com/google/devtools/build/lib/remote/http/HttpUploadHandler.java
@@ -36,6 +36,8 @@ import io.netty.util.internal.StringUtil;
 import java.io.IOException;
 import java.util.Map.Entry;
 
+import com.google.devtools.build.lib.authandtls.AuthAndTLSOptions;
+
 /** ChannelHandler for uploads. */
 final class HttpUploadHandler extends AbstractHttpHandler<FullHttpResponse> {
 
@@ -45,8 +47,8 @@ final class HttpUploadHandler extends AbstractHttpHandler<FullHttpResponse> {
   private long contentLength;
 
   public HttpUploadHandler(
-      Credentials credentials, ImmutableList<Entry<String, String>> extraHttpHeaders) {
-    super(credentials, extraHttpHeaders);
+      Credentials credentials, ImmutableList<Entry<String, String>> extraHttpHeaders, String awsId, String awsSecret) {
+    super(credentials, extraHttpHeaders, awsId, awsSecret);
   }
 
   @SuppressWarnings("FutureReturnValueIgnored")
@@ -103,6 +105,7 @@ final class HttpUploadHandler extends AbstractHttpHandler<FullHttpResponse> {
     addCredentialHeaders(request, cmd.uri());
     addExtraRemoteHeaders(request);
     addUserAgentHeader(request);
+    addAwsAuthenticationHeaders(request, path);
     HttpChunkedInput body = buildBody(cmd);
     ctx.writeAndFlush(request)
         .addListener(
diff --git a/src/main/java/com/google/devtools/build/lib/runtime/BlazeOptionHandler.java b/src/main/java/com/google/devtools/build/lib/runtime/BlazeOptionHandler.java
index 57ad0283a3..bbf7abbb02 100644
--- a/src/main/java/com/google/devtools/build/lib/runtime/BlazeOptionHandler.java
+++ b/src/main/java/com/google/devtools/build/lib/runtime/BlazeOptionHandler.java
@@ -274,7 +274,7 @@ public final class BlazeOptionHandler {
       StarlarkOptionsParser.newStarlarkOptionsParser(env, optionsParser).parse(eventHandler);
     } catch (OptionsParsingException e) {
       String logMessage = "Error parsing Starlark options";
-      logger.atInfo().withCause(e).log(logMessage);
+      logger.atInfo().withCause(e).log("%s", logMessage);
       return processOptionsParsingException(
           eventHandler, e, logMessage, Code.STARLARK_OPTIONS_PARSE_FAILURE);
     }
@@ -343,7 +343,7 @@ public final class BlazeOptionHandler {
       }
     } catch (OptionsParsingException e) {
       String logMessage = "Error parsing options";
-      logger.atInfo().withCause(e).log(logMessage);
+      logger.atInfo().withCause(e).log("%s", logMessage);
       return processOptionsParsingException(
           eventHandler, e, logMessage, Code.OPTIONS_PARSE_FAILURE);
     } catch (InterruptedException e) {
diff --git a/src/main/java/com/google/devtools/build/lib/runtime/BlazeRuntime.java b/src/main/java/com/google/devtools/build/lib/runtime/BlazeRuntime.java
index 77f1f5fb4c..0776f9f535 100644
--- a/src/main/java/com/google/devtools/build/lib/runtime/BlazeRuntime.java
+++ b/src/main/java/com/google/devtools/build/lib/runtime/BlazeRuntime.java
@@ -946,7 +946,7 @@ public final class BlazeRuntime implements BugReport.BlazeRuntimeInterface {
     boolean shutdownDone = false;
 
     try {
-      logger.atInfo().log(
+      logger.atInfo().log("%s",
           SafeRequestLogging.getRequestLogString(commandLineOptions.getOtherArgs()));
       BlazeCommandResult result =
           dispatcher.exec(
diff --git a/src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java b/src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java
index daad07acc7..43db142741 100644
--- a/src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java
+++ b/src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java
@@ -138,7 +138,7 @@ public class BuildSummaryStatsModule extends BlazeModule {
           event.getResult().getBuildToolLogCollection()
               .addDirectValue(
                   "critical path", criticalPath.toString().getBytes(StandardCharsets.UTF_8));
-          logger.atInfo().log(criticalPath.toString());
+          logger.atInfo().log("%s", criticalPath.toString());
           logger.atInfo().log(
               "Slowest actions:\n  %s",
               Joiner.on("\n  ").join(criticalPathComputer.getSlowestComponents()));
diff --git a/src/main/java/com/google/devtools/build/lib/server/GrpcServerImpl.java b/src/main/java/com/google/devtools/build/lib/server/GrpcServerImpl.java
index 5a9df0b866..9f73f5a3db 100644
--- a/src/main/java/com/google/devtools/build/lib/server/GrpcServerImpl.java
+++ b/src/main/java/com/google/devtools/build/lib/server/GrpcServerImpl.java
@@ -545,7 +545,7 @@ public class GrpcServerImpl extends CommandServerGrpc.CommandServerImplBase impl
             .collect(ImmutableList.toImmutableList());
 
         InvocationPolicy policy = InvocationPolicyParser.parsePolicy(request.getInvocationPolicy());
-        logger.atInfo().log(SafeRequestLogging.getRequestLogString(args));
+        logger.atInfo().log("%s", SafeRequestLogging.getRequestLogString(args));
         result =
             dispatcher.exec(
                 policy,
diff --git a/src/main/java/com/google/devtools/build/lib/server/ShutdownHooks.java b/src/main/java/com/google/devtools/build/lib/server/ShutdownHooks.java
index a9b3b224da..e8c76bd46d 100644
--- a/src/main/java/com/google/devtools/build/lib/server/ShutdownHooks.java
+++ b/src/main/java/com/google/devtools/build/lib/server/ShutdownHooks.java
@@ -84,6 +84,6 @@ public class ShutdownHooks {
     printErr.println("=======[BAZEL SERVER: ENCOUNTERED IO EXCEPTION]=======");
     e.printStackTrace(printErr);
     printErr.println("=====================================================");
-    logger.atSevere().log(err.toString());
+    logger.atSevere().log("%s", err.toString());
   }
 }
diff --git a/src/main/java/com/google/devtools/build/lib/shell/Command.java b/src/main/java/com/google/devtools/build/lib/shell/Command.java
index 7ca600cc35..ce7f287cd4 100644
--- a/src/main/java/com/google/devtools/build/lib/shell/Command.java
+++ b/src/main/java/com/google/devtools/build/lib/shell/Command.java
@@ -370,7 +370,7 @@ public final class Command implements DescribableExecutionUnit {
   }
 
   private FutureCommandResult doExecute(
-      InputStream stdinInput, OutErrConsumers outErrConsumers, boolean killSubprocessOnInterrupt) 
+      InputStream stdinInput, OutErrConsumers outErrConsumers, boolean killSubprocessOnInterrupt)
           throws ExecFailedException {
     Preconditions.checkNotNull(stdinInput, "stdinInput");
     logCommand();
@@ -410,7 +410,7 @@ public final class Command implements DescribableExecutionUnit {
   }
 
   private static void processInput(InputStream stdinInput, Subprocess process) {
-    logger.atFiner().log(stdinInput.toString());
+    logger.atFiner().log("%s", stdinInput.toString());
     try (OutputStream out = process.getOutputStream()) {
       ByteStreams.copy(stdinInput, out);
     } catch (IOException ioe) {
diff --git a/src/main/java/com/google/devtools/build/lib/skyframe/SequencedSkyframeExecutor.java b/src/main/java/com/google/devtools/build/lib/skyframe/SequencedSkyframeExecutor.java
index 3a56b5c73b..63f6e29209 100644
--- a/src/main/java/com/google/devtools/build/lib/skyframe/SequencedSkyframeExecutor.java
+++ b/src/main/java/com/google/devtools/build/lib/skyframe/SequencedSkyframeExecutor.java
@@ -651,7 +651,7 @@ public final class SequencedSkyframeExecutor extends SkyframeExecutor {
       }
     }
 
-    logger.atInfo().log(result.toString());
+    logger.atInfo().log("%s", result.toString());
   }
 
   private static int getNumberOfModifiedFiles(Iterable<SkyKey> modifiedValues) {
